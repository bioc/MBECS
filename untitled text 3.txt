  # this is the un-adjusted variance --> divide by total variance and done
  vc <- mbecMixedVariance(model.fit)
  
  # BUT maybe we want to adjust/condition for one or more variables.. and make this shit more complicated than it needs to be
  
  adjust = NULL # some arbitrary adjustment for development
  
  # 1. make this adjustment validity check
  # check for varying coefficient models - whatever that is.. copy and paste for now
  if (max(sapply(varComp, length)) > 1 && !is.null(adjust)) {
    stop("The adjust and adjustAll arguments are not currently supported for varying coefficient models")
  }
  # 2. for all covariates perform the variance calculation - for varying coefficients the total sum is somehow only this particular coefficient + all other variables - BUT the other coefficient level are ignored here
  ret.var <- c()
  for( effect in names(vc) ) {
    # if there are varying coefficients present
    if( grepl("\\.", effect) ) {
      print("muh")
      # extract main factor to exclude all coefficients that belong to it
      main.eff <- unlist(strsplit(effect, split="\\."))[1]
      # sum up all values except the other coefficient values
      tmp.total.var <- sum(vc[!grepl(main.eff, names(vc))], vc[effect])
      ret.var[eval(effect)] <- vc[effect] / tmp.total.var
      
    } else {
      # if there is only a single coefficient present here - then just sum up all the values
      ret.var[eval(effect)] <- vc[effect] / sum(vc)
      
    }
    
    
    
That is, to find P(X=x), we sum all the probability values where X=x occurs with all possible values of Y. This makes sense, intuitively. To see how, let’s say Y can take on n values: y1,y2,...,n. We can find how often X=x occurs if we consider how often X=x occurs with each individual value of Y, and sum up all such values to get the total value of the “often-ness” of X.